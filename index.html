<!DOCTYPE html>
<html lang="vi" class="scroll-smooth">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Magic Block! ‚Äî Block Blast Style</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* --- Bi·∫øn CSS cho m√†u s·∫Øc v√† kho·∫£ng c√°ch --- */
      :root {
        --bg-main: #24345c;
        --bg-dark: #1e2c4a;
        --panel: #3d5082;
        --text-color: #e2e8f0;
        --score-color: #fce38a;
        --accent-color: #8be4ff;
      }

      /* --- C·∫•u h√¨nh chung v√† Typography --- */
      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg-main);
        color: var(--text-color);
        font-family: "Poppins", system-ui, sans-serif;
        transition: background-color 0.4s ease;
        overflow: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* ·∫®n thanh cu·ªôn ƒë·ªÉ tr·∫£i nghi·ªám t·ªët h∆°n */
      body::-webkit-scrollbar {
        display: none;
      }
      body {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      /* Hi·ªáu ·ª©ng nh·∫•n n√∫t m∆∞·ª£t m√† */
      button:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.5);
      }

      /* --- C·∫•u tr√∫c ch√≠nh c·ªßa ·ª©ng d·ª•ng --- */
      .wrap {
        max-width: 420px;
        margin: 10px auto;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
        position: relative;
        height: calc(100% - 20px);
        box-sizing: border-box;
        user-select: none;
      }

      /* --- Thi·∫øt k·∫ø cho c√°c ti√™u ƒë·ªÅ v√† vƒÉn b·∫£n --- */
      h1,
      h2 {
        margin: 0;
        font-weight: 900;
        letter-spacing: -0.03em;
        user-select: none;
      }
      h1 {
        font-size: 28px;
        background: linear-gradient(90deg, var(--accent-color), #8be4ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.3);
      }

      /* --- Thanh th√¥ng tin ƒëi·ªÉm s·ªë v√† n√∫t --- */
      .bar {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        margin-bottom: 18px;
        user-select: none;
      }
      .tag {
        background: var(--panel);
        border-radius: 12px;
        padding: 6px 14px;
        border: 2px solid #556c9a;
        font-weight: 700;
        box-shadow: 0 5px 8px rgba(0, 0, 0, 0.1);
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 4px;
        user-select: none;
        transition: background-color 0.3s ease;
      }
      .tag:hover {
        background-color: #4a6092;
        cursor: default;
      }
      .score-display {
        font-size: 52px;
        font-weight: 900;
        color: var(--score-color);
        text-shadow: 3px 3px 8px rgba(0, 0, 0, 0.4);
        margin-top: -8px;
        user-select: none;
        letter-spacing: 0.02em;
        transition: color 0.3s ease;
      }
      .menu-btn {
        border: 2px solid #556c9a;
        padding: 8px 14px;
        border-radius: 12px;
        background: var(--panel);
        color: var(--text-color);
        cursor: pointer;
        font-size: 20px;
        font-weight: 800;
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.12);
        transition: background-color 0.3s ease, transform 0.15s ease;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .menu-btn:hover {
        background-color: #4a6092;
        transform: scale(1.05);
      }
      .menu-btn:active {
        transform: scale(0.95);
      }

      /* --- Khu v·ª±c khay ch·ª©a kh·ªëi --- */
      .tray-section {
        position: relative;
        width: 100%;
        padding-top: 10px;
        box-sizing: border-box;
      }
      
      /* --- Hi·ªáu ·ª©ng b√≥ng v√† g√≥c bo tr√≤n cho canvas --- */
      canvas {
        border-radius: 14px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
        touch-action: none;
        display: block;
        margin-top: 6px;
        transition: transform 0.15s ease, box-shadow 0.3s ease;
        background: var(--bg-dark);
        image-rendering: optimizeSpeed;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: pixelated;
        max-width: 100%;
        height: auto;
      }
      canvas:active {
        transform: scale(0.98);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.8);
      }

      /* --- C√°c khung nh√¨n (Home, Game, Settings) --- */
      .views {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        padding: 0 16px;
        box-sizing: border-box;
        user-select: none;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.4s ease, visibility 0.4s ease;
      }
      .views.active {
        opacity: 1;
        visibility: visible;
        z-index: 10;
      }

      /* --- Home View --- */
      .home-title {
        font-size: 54px;
        font-weight: 900;
        background: linear-gradient(
          45deg,
          #ffd700,
          #f08080,
          #38b6ff,
          #a855f7,
          #f43f5e
        );
        background-size: 400% 400%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 6px 14px rgba(0, 0, 0, 0.3);
        letter-spacing: -0.04em;
        margin-bottom: 24px;
        animation: gradientShift 12s ease infinite;
        user-select: none;
      }
      @keyframes gradientShift {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }
      .home-subtitle {
        font-size: 18px;
        font-weight: 700;
        color: #dbeafe;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.25);
        margin-top: -16px;
        margin-bottom: 28px;
        user-select: none;
        letter-spacing: 0.03em;
      }

      /* --- N√∫t chung --- */
      .main-btn {
        padding: 16px 40px;
        border-radius: 14px;
        font-size: 22px;
        font-weight: 900;
        border: 0;
        color: #fff;
        cursor: pointer;
        min-width: 240px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
        transition: transform 0.25s ease, box-shadow 0.25s ease,
          background-color 0.3s ease;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        border: 2px solid #556c9a;
      }
      .main-btn:active {
        transform: translateY(3px);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .btn-play {
        background: linear-gradient(180deg, #51d7fb 0%, #0093e1 100%);
        box-shadow: 0 8px 24px #0093e1aa;
      }
      .btn-play:hover {
        background: linear-gradient(180deg, #3bb0e8 0%, #0071b8 100%);
        box-shadow: 0 10px 30px #0071b8cc;
      }
      .btn-settings-home {
        background: #334155;
        color: var(--text-color);
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        font-weight: 700;
        transition: background-color 0.3s ease;
      }
      .btn-settings-home:hover {
        background-color: #475569;
      }

      /* --- M√†n h√¨nh Game Over --- */
      .overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(2, 6, 23, 0.85);
        z-index: 9999;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.35s ease, visibility 0.35s ease;
        user-select: none;
        padding: 16px;
        box-sizing: border-box;
      }
      .overlay.show {
        visibility: visible;
        opacity: 1;
      }
      .modal {
        background: var(--panel);
        border-radius: 20px;
        padding: 28px 32px;
        min-width: 280px;
        max-width: 90vw;
        text-align: center;
        box-shadow: 0 14px 42px rgba(0, 0, 0, 0.8);
        border: 2px solid #556c9a;
        color: var(--text-color);
        transform: scale(0.9);
        transition: transform 0.35s ease, opacity 0.35s ease;
        user-select: none;
      }
      .overlay.show .modal {
        transform: scale(1);
      }
      .game-over-title {
        font-size: 38px;
        font-weight: 900;
        margin: 0 0 16px 0;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        letter-spacing: -0.03em;
      }
      .modal-score {
        font-size: 28px;
        font-weight: 800;
        color: var(--score-color);
        margin-bottom: 10px;
        letter-spacing: 0.02em;
      }
      .modal-best {
        font-size: 16px;
        color: rgba(255, 255, 255, 0.85);
        font-weight: 600;
        margin-bottom: 20px;
        letter-spacing: 0.02em;
      }
      .modal button {
        margin-top: 20px;
      }

      /* --- Menu C√†i ƒë·∫∑t --- */
      .settings-modal {
        display: flex;
        flex-direction: column;
        gap: 14px;
        position: relative;
        user-select: none;
      }
      .settings-modal h2 {
        margin: 0;
        font-size: 22px;
        font-weight: 900;
        letter-spacing: -0.02em;
        color: #e0e7ff;
        text-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }
      .settings-modal .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: transparent;
        border: 0;
        color: var(--text-color);
        font-size: 24px;
        cursor: pointer;
        transition: color 0.3s ease;
        user-select: none;
      }
      .settings-modal .close-btn:hover {
        color: #f87171;
      }
      .settings-options {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 16px;
      }
      .settings-options .btn {
        width: 60px;
        height: 60px;
        background: var(--bg-dark);
        border-radius: 14px;
        font-size: 26px;
        color: var(--text-color);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.12);
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        border: 2px solid #556c9a;
      }
      .settings-options .btn:hover {
        background-color: #4a6092;
        transform: scale(1.1);
      }
      .settings-options .btn:active {
        transform: scale(0.95);
      }
      .tray-piece-wrap {
        position: relative;
        height: 100%;
        width: 100%;
      }
      .rotate-btn {
        position: absolute;
        top: 6px;
        right: 6px;
        width: 28px;
        height: 28px;
        background: rgba(0, 0, 0, 0.3);
        border: 1.5px solid #fff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        color: #fff;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
        z-index: 10;
      }
      .rotate-btn:hover {
        background: rgba(0, 0, 0, 0.5);
        transform: scale(1.1);
      }
      .rotate-btn:active {
        transform: scale(0.9);
      }
    </style>
  </head>
  <body>
    <div class="wrap" id="main-wrap">
      <div id="home-view" class="views active" role="main" aria-label="Trang ch·ªß tr√≤ ch∆°i">
        <h2 class="home-title" aria-label="Ti√™u ƒë·ªÅ tr√≤ ch∆°i Block Blast">BLOCK BLAST</h2>
        <div class="home-subtitle" aria-label="Ph·ª• ƒë·ªÅ tr√≤ ch∆°i">ADVENTURE MASTER</div>
        <button
          id="classic-btn"
          class="main-btn btn-play"
          style="
            background: linear-gradient(180deg, #51d7fb 0%, #0093e1 100%);
            margin-top: 20px;
          "
          aria-label="B·∫Øt ƒë·∫ßu ch∆°i ch·∫ø ƒë·ªô Classic"
        >
          <span style="font-size: 28px; margin-right: 10px" aria-hidden="true">‚ôæÔ∏è</span>
          Classic
        </button>
        <button
          id="dynamic-btn"
          class="main-btn"
          style="
            background: linear-gradient(180deg, #f08080 0%, #d80000 100%);
          "
          aria-label="B·∫Øt ƒë·∫ßu ch∆°i ch·∫ø ƒë·ªô Dynamic"
        >
          <span style="font-size: 28px; margin-right: 10px" aria-hidden="true">üîÑ</span>
          Dynamic
        </button>
      </div>

      <div id="game-view" class="views" role="main" aria-label="Khu v·ª±c ch∆°i game">
        <div class="bar" role="region" aria-live="polite" aria-atomic="true" aria-relevant="text">
          <div class="tag" aria-label="ƒêi·ªÉm cao nh·∫•t hi·ªán t·∫°i">
            <i class="fas fa-crown" aria-hidden="true"></i>
            <span id="best">0</span>
          </div>
          <div class="score-display" aria-label="ƒêi·ªÉm hi·ªán t·∫°i">
            <span id="score">0</span>
          </div>
          <button
            id="pause-btn"
            class="menu-btn"
            aria-haspopup="dialog"
            aria-controls="pause-overlay"
            aria-label="M·ªü menu t·∫°m d·ª´ng"
          >
            <i class="fas fa-pause" aria-hidden="true"></i>
          </button>
        </div>
        <canvas id="game" role="img" aria-label="B·∫£ng ch∆°i game 10 tr√™n 10 √¥"></canvas>
        <div class="tray-section">
          <div class="tray-pieces-container flex justify-between w-full"></div>
        </div>
      </div>
    </div>

    <div
      id="gameover-overlay"
      class="overlay"
      role="dialog"
      aria-modal="true"
      aria-labelledby="overlay-title"
      aria-describedby="overlay-score overlay-best"
    >
      <div class="modal">
        <h2 id="overlay-title" class="game-over-title">Game Over</h2>
        <div class="modal-score">ƒêi·ªÉm: <span id="overlay-score">0</span></div>
        <div class="modal-best">K·ª∑ l·ª•c: <span id="overlay-best">0</span></div>
        <button
          id="overlay-replay"
          class="btn-play main-btn"
          style="margin-top: 20px"
          aria-label="Ch∆°i l·∫°i"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewbox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            style="margin-right: 8px; vertical-align: middle"
            aria-hidden="true"
            focusable="false"
          >
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
          Ch∆°i l·∫°i
        </button>
      </div>
    </div>

    <div
      id="pause-overlay"
      class="overlay"
      role="dialog"
      aria-modal="true"
      aria-labelledby="pause-title"
      aria-describedby="pause-desc"
    >
      <div class="modal settings-modal">
        <button id="close-pause" class="close-btn" aria-label="Ti·∫øp t·ª•c ch∆°i">
          ‚úñÔ∏è
        </button>
        <h2 id="pause-title">T·∫°m d·ª´ng</h2>
        <p id="pause-desc" class="sr-only">
          C√°c t√πy ch·ªçn c√†i ƒë·∫∑t √¢m thanh v√† ƒëi·ªÅu khi·ªÉn tr√≤ ch∆°i
        </p>
        <div class="settings-options" role="group" aria-label="T√πy ch·ªçn √¢m thanh">
          <button id="mute-btn" class="btn" aria-pressed="true" aria-label="B·∫≠t/t·∫Øt √¢m thanh">
            üîä
          </button>
          <button id="bgm-btn" class="btn" aria-pressed="false" aria-label="B·∫≠t/t·∫Øt nh·∫°c n·ªÅn">
            üéµ
          </button>
        </div>
        <button
          id="replay-in-pause"
          class="btn-play main-btn"
          aria-label="Ch∆°i l·∫°i tr√≤ ch∆°i"
        >
          Ch∆°i l·∫°i
        </button>
        <button
          id="back-to-home"
          class="btn-settings-home main-btn"
          aria-label="Quay v·ªÅ trang ch·ªß"
        >
          V·ªÅ Home
        </button>
      </div>
    </div>

    <script>
      /* ----------------- C·∫§U H√åNH C·ªê ƒê·ªäNH C·ª¶A TR√í CH∆†I ----------------- */
      const GRID = 9; // ƒê√£ thay ƒë·ªïi k√≠ch th∆∞·ªõc b·∫£ng ch∆°i th√†nh 9x9
      let CELL, GAP, BOARD_PAD, BOARD_SIZE, CANVAS_W, CANVAS_H, TRAY_TOP, TRAY_HEIGHT;
      let isPaused = false;

      const COLORS = [
        "#e80000",
        "#d47006",
        "#f0bd13",
        "#18f21e",
        "#0fa8f2",
        "#1c14db",
        "#7a15ed",
        "#f5189e",
      ];
      const SHAPES = [
        [[0, 0]],
        [[0, 0], [1, 0]],
        [[0, 0], [0, 1]],
        [[0, 0], [1, 0], [2, 0]],
        [[0, 0], [0, 1], [0, 2]],
        [[0, 0], [1, 0], [0, 1], [1, 1]],
        [[0, 0], [1, 0], [2, 0], [3, 0]],
        [[0, 0], [0, 1], [0, 2], [0, 3]],
        [[0, 0], [1, 0], [2, 0], [1, 1]],
        [[0, 0], [0, 1], [0, 2], [1, 2]],
        [[0, 0], [1, 0], [1, 1], [2, 1]],
        [[0, 0], [1, 0], [2, 0], [2, 1]],
        [[0, 1], [1, 1], [2, 1], [2, 0]],
        [[0, 0], [0, 1], [1, 1], [2, 1]],
        [[0, 0], [0, 1], [1, 0], [2, 0]],
        [
          [0, 0],
          [1, 0],
          [2, 0],
          [0, 1],
          [1, 1],
          [2, 1],
          [0, 2],
          [1, 2],
          [2, 2],
        ],
        // Th√™m kh·ªëi 2x3 v√† phi√™n b·∫£n xoay c·ªßa n√≥
        [[0, 0], [1, 0], [0, 1], [1, 1], [0, 2], [1, 2]],
        [[0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1]]
      ];

      /* ----------------- C√ÅC BI·∫æN TR·∫†NG TH√ÅI C·ª¶A TR√í CH∆†I ----------------- */
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const bestEl = document.getElementById("best");
      const gameoverOverlay = document.getElementById("gameover-overlay");
      const pauseOverlay = document.getElementById("pause-overlay");
      const overlayScore = document.getElementById("overlay-score");
      const overlayBest = document.getElementById("overlay-best");
      const overlayReplay = document.getElementById("overlay-replay");
      const muteBtn = document.getElementById("mute-btn");
      const bgmBtn = document.getElementById("bgm-btn");
      const replayInPauseBtn = document.getElementById("replay-in-pause");
      const homeView = document.getElementById("home-view");
      const gameView = document.getElementById("game-view");
      const classicBtn = document.getElementById("classic-btn");
      const dynamicBtn = document.getElementById("dynamic-btn");
      const pauseBtn = document.getElementById("pause-btn");
      const closePauseBtn = document.getElementById("close-pause");
      const backToHomeBtn = document.getElementById("back-to-home");
      const trayPiecesContainer = document.querySelector(".tray-pieces-container");

      let board = null;
      let tray = null;
      let dragging = null;
      let dragPos = null;
      let score = 0;
      let best = parseInt(localStorage.getItem("bb_best_polished") || "0", 10) || 0;
      bestEl.textContent = best;
      let clearingAnim = null;
      let dirty = true;
      let returnAnim = null;
      let floatingTexts = [];
      let popAnims = new Map();
      let audioEnabled = true;
      let sparks = [];
      let gameoverAnim = null;
      let starParticles = [];
      let bgmAudio = null;
      let bgmEnabled = false;
      let gameMode = "classic";
      let rafId = null; // ƒê·ªÉ qu·∫£n l√Ω requestAnimationFrame

      /* ---------- √ÇM THANH (c√°c t·ªáp online) ---------- */
      const SOUND_URLS = {
        place: "https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg",
        clear: "https://actions.google.com/sounds/v1/cartoon/pop.ogg",
        gameover: "https://actions.google.com/sounds/v1/alarms/beep_short.ogg",
        victory: "https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg",
        rotate: "https://actions.google.com/sounds/v1/cartoon/boing.ogg",
        bgm: "https://actions.google.com/sounds/v1/cartoon/swish_in_and_out.ogg",
      };
      const audio = {};
      for (const k in SOUND_URLS) {
        audio[k] = new Audio(SOUND_URLS[k]);
        audio[k].preload = "auto";
      }

      function playSound(k) {
        if (!audioEnabled) return;
        try {
          const a = audio[k];
          if (a) {
            a.currentTime = 0;
            a.play().catch(() => {});
          }
        } catch (e) {}
      }

      function toggleBGM() {
        bgmEnabled = !bgmEnabled;
        if (bgmEnabled) {
          if (!bgmAudio) {
            bgmAudio = new Audio(SOUND_URLS.bgm);
            bgmAudio.loop = true;
            bgmAudio.volume = 0.5;
          }
          bgmAudio.play().catch(() => {});
          bgmBtn.textContent = "üé∂";
          bgmBtn.setAttribute("aria-pressed", "true");
        } else {
          if (bgmAudio) {
            bgmAudio.pause();
          }
          bgmBtn.textContent = "üéµ";
          bgmBtn.setAttribute("aria-pressed", "false");
        }
      }
      
      function togglePause() {
          isPaused = !isPaused;
          if (isPaused) {
              pauseOverlay.classList.add('show');
              pauseBtn.innerHTML = '<i class="fas fa-play"></i>';
              if (bgmEnabled && bgmAudio) bgmAudio.pause();
              cancelAnimationFrame(rafId);
              rafId = null;
          } else {
              pauseOverlay.classList.remove('show');
              pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
              if (bgmEnabled && bgmAudio) bgmAudio.play().catch(() => {});
              if (!rafId) tick();
          }
      }

      /* ------------- C√ÅC H√ÄM TI·ªÜN √çCH CHUNG ------------- */
      const rand = (a) => a[Math.floor(Math.random() * a.length)];
      const now = () => performance.now();
      function cloneShape(s) {
        return s.map(([x, y]) => [x, y]);
      }
      function rotateRight(cells) {
        const rot = cells.map(([x, y]) => [y, -x]);
        const minX = Math.min(...rot.map((c) => c[0])),
          minY = Math.min(...rot.map((c) => c[1]));
        return rot.map(([x, y]) => [x - minX, y - minY]);
      }
      function boundsOf(cells) {
        const xs = cells.map((c) => c[0]),
          ys = cells.map((c) => c[1]);
        return { w: Math.max(...xs) + 1, h: Math.max(...ys) + 1 };
      }
      function emptyBoard() {
        return Array.from({ length: GRID }, () => Array(GRID).fill(0));
      }
      function keyOf(x, y) {
        return `${x},${y}`;
      }

      /* ----------------- ƒêI·ªÄU CH·ªàNH K√çCH TH∆Ø·ªöC ƒê·ªòNG ----------------- */
      function resizeGame() {
        const wrap = document.getElementById("main-wrap");
        const wrapWidth = wrap.clientWidth * 0.8;
        const boardRatio = 1.0;
        const trayRatio = 0.4;
        const boardHeight = wrapWidth * boardRatio;
        const trayHeight = wrapWidth * trayRatio;

        CANVAS_W = wrapWidth;
        CANVAS_H = boardHeight + trayHeight + 40;

        CELL = (CANVAS_W * 0.9) / GRID;
        GAP = CELL * 0.1;
        CELL = (CANVAS_W - (GRID + 1) * GAP) / GRID;
        BOARD_SIZE = GRID * CELL + (GRID - 1) * GAP;
        BOARD_PAD = (CANVAS_W - BOARD_SIZE) / 2;

        TRAY_TOP = BOARD_PAD + BOARD_SIZE + 24;
        TRAY_HEIGHT = trayHeight * 0.8;

        canvas.width = CANVAS_W * devicePixelRatio;
        canvas.height = CANVAS_H * devicePixelRatio;
        canvas.style.width = CANVAS_W + "px";
        canvas.style.height = CANVAS_H + "px";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(devicePixelRatio, devicePixelRatio);

        dirty = true;
      }

      /* ------------- KH·ªûI T·∫†O V√Ä C·∫§U TR√öC L·∫†I KHAY ------------- */
      function randomPiece() {
        const base = cloneShape(rand(SHAPES));
        const r = Math.floor(Math.random() * 4);
        let s = base;
        for (let i = 0; i < r; i++) s = rotateRight(s);
        return { shape: s, color: rand(COLORS), used: false, slotRect: null, rotatable: gameMode === 'dynamic' };
      }

      function layoutTray() {
        trayPiecesContainer.innerHTML = "";
        const leftPad = 12;
        const gapSlot = 10;
        const totalGap = gapSlot * 2;
        const slotW = Math.floor((CANVAS_W - leftPad * 2 - totalGap) / 3);

        for (let i = 0; i < 3; i++) {
          const x = leftPad + i * (slotW + gapSlot);
          tray[i].slotRect = { x, y: TRAY_TOP, w: slotW, h: TRAY_HEIGHT };

          const pieceDiv = document.createElement("div");
          pieceDiv.className = "tray-piece-wrap relative";
          pieceDiv.style.width = `${slotW}px`;
          pieceDiv.style.height = `${TRAY_HEIGHT}px`;
          pieceDiv.setAttribute('data-piece-index', i);

          if (tray[i].rotatable) {
            const rotateBtn = document.createElement('button');
            rotateBtn.className = "rotate-btn";
            rotateBtn.innerHTML = "üîÑ";
            rotateBtn.setAttribute('aria-label', `Xoay kh·ªëi ${i + 1}`);
            pieceDiv.appendChild(rotateBtn);
          }
          trayPiecesContainer.appendChild(pieceDiv);
        }
        dirty = true;
      }

      function initGame(mode) {
        gameMode = mode;
        resizeGame();
        board = emptyBoard();
        tray = [randomPiece(), randomPiece(), randomPiece()];
        layoutTray();
        score = 0;
        scoreEl.textContent = score;
        clearingAnim = null;
        returnAnim = null;
        floatingTexts = [];
        sparks = [];
        popAnims.clear();
        gameoverAnim = null;
        dragging = null;
        dragPos = null;
        hideGameoverOverlay();
        hidePauseOverlay();
        isPaused = false;
        pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        dirty = true;
        if (!rafId) tick();
      }

      /* ------------- TR·ª¢ L√ù V·∫º C·ª¶A CANVAS ------------- */
      function roundedRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      }
      function drawBoardPanel() {
        ctx.fillStyle = "#3d5082";
        roundedRect(BOARD_PAD - 8, BOARD_PAD - 8, BOARD_SIZE + 16, BOARD_SIZE + 16, 16);
        ctx.shadowColor = "rgba(0,0,0,0.4)";
        ctx.shadowBlur = 16;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = "#556c9a";
        ctx.lineWidth = 3;
        roundedRect(BOARD_PAD - 8, BOARD_PAD - 8, BOARD_SIZE + 16, BOARD_SIZE + 16, 16);
        ctx.stroke();
      }
      function drawGrid() {
        for (let y = 0; y < GRID; y++) {
          for (let x = 0; x < GRID; x++) {
            const cx = BOARD_PAD + x * (CELL + GAP);
            const cy = BOARD_PAD + y * (CELL + GAP);
            const val = board[y][x];
            if (val) {
              const k = keyOf(x, y);
              let scale = 1;
              if (popAnims.has(k)) {
                const anim = popAnims.get(k);
                const t = Math.min(1, (now() - anim.start) / anim.dur);
                scale = 1 + 0.08 * (1 - Math.pow(1 - t, 2));
                if (t >= 1) popAnims.delete(k);
              }
              const s = CELL * scale,
                off = (CELL - s) / 2;
              const gx = cx + off,
                gy = cy + off;

              ctx.fillStyle = val;
              roundedRect(gx, gy, s, s, 6);
              ctx.shadowColor = "rgba(0,0,0,0.3)";
              ctx.shadowBlur = 5;
              ctx.fill();
              ctx.shadowBlur = 0;

              ctx.strokeStyle = "#fff";
              ctx.lineWidth = 1.5;
              ctx.globalAlpha = 0.2;
              roundedRect(gx + 1, gy + 1, s - 2, s - 2, 6);
              ctx.stroke();

              ctx.globalAlpha = 1;
            } else {
              ctx.fillStyle = "#2a448c";
              roundedRect(cx, cy, CELL, CELL, 8);
              ctx.shadowColor = "rgba(0,0,0,0.15)";
              ctx.shadowBlur = 3;
              ctx.fill();
              ctx.shadowBlur = 0;
            }
          }
        }
      }
      function drawTray() {
        for (let i = 0; i < 3; i++) {
          const s = tray[i].slotRect;
          ctx.fillStyle = "rgba(0,0,0,0.25)";
          roundedRect(s.x, s.y, s.w, s.h, 12);
          ctx.shadowColor = "rgba(0,0,0,0.3)";
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = "rgba(255,255,255,0.1)";
          ctx.lineWidth = 1;
          roundedRect(s.x, s.y, s.w, s.h, 12);
          ctx.stroke();
          if (!tray[i].used && !(dragging && dragging.pieceIdx === i && !returnAnim)) {
            drawPieceInSlot(tray[i], s, {
              fade: dragging && dragging.pieceIdx === i ? 0.5 : 1,
            });
          } else if (tray[i].used) {
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            roundedRect(s.x, s.y, s.w, s.h, 12);
            ctx.fill();
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.font = `700 ${12}px Poppins`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("ƒê√£ d√πng", s.x + s.w / 2, s.y + s.h / 2);
          }
        }
      }
      function drawPieceInSlot(piece, slot, { fade = 1 } = {}) {
        const { w, h } = boundsOf(piece.shape);
        const unit = 22,
          gap = 4;
        const pw = w * unit + (w - 1) * gap,
          ph = h * unit + (h - 1) * gap;
        const px = slot.x + Math.round((slot.w - pw) / 2),
          py = slot.y + Math.round((slot.h - ph) / 2);
        for (const [dx, dy] of piece.shape) {
          const x = px + dx * (unit + gap),
            y = py + dy * (unit + gap);
          ctx.globalAlpha = fade;
          ctx.fillStyle = piece.color;
          roundedRect(x, y, unit, unit, 6);
          ctx.shadowColor = "rgba(0,0,0,0.3)";
          ctx.shadowBlur = 6;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.2;
          ctx.fillStyle = "#fff";
          roundedRect(x + 1, y + 1, unit - 2, unit - 2, 6);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }
      function ghostFromPointer(piece, mx, my) {
        if (
          mx < BOARD_PAD ||
          my < BOARD_PAD ||
          mx > BOARD_PAD + BOARD_SIZE ||
          my > BOARD_PAD + BOARD_SIZE
        )
          return null;
        const relX = mx - BOARD_PAD,
          relY = my - BOARD_PAD;
        const stride = CELL + GAP;
        const gx = Math.floor(relX / stride);
        const gy = Math.floor(relY / stride);
        const cells = [],
          out = { valid: true };
        for (const [dx, dy] of piece.shape) {
          const x = gx + dx,
            y = gy + dy;
          if (x < 0 || x >= GRID || y < 0 || y >= GRID) out.valid = false;
          else if (board[y][x] !== 0) out.valid = false;
          cells.push([x, y]);
        }
        out.valid = out.valid && cells.length > 0;
        out.cells = cells;
        out.gx = gx;
        out.gy = gy;
        return out;
      }
      function drawGhost(cells, valid) {
        if (!cells) return;
        ctx.globalAlpha = 0.36;
        ctx.fillStyle = valid ? "#10b981" : "#ef4444";
        for (const [x, y] of cells) {
          if (x < 0 || y < 0 || x >= GRID || y >= GRID) continue;
          const cx = BOARD_PAD + x * (CELL + GAP),
            cy = BOARD_PAD + y * (CELL + GAP);
          roundedRect(cx, cy, CELL, CELL, 8);
          ctx.shadowColor = valid ? "#10b981aa" : "#ef4444aa";
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;
      }
      function drawDraggedPieceVisual() {
        if (!dragging || !dragPos) return;
        const piece = tray[dragging.pieceIdx];
        const { w, h } = boundsOf(piece.shape);
        const unit = 30,
          gap = 6;
        for (const [dx, dy] of piece.shape) {
          const x = dragPos.x - dragging.offsetX + dx * (unit + gap);
          const y = dragPos.y - dragging.offsetY + dy * (unit + gap);
          ctx.save();
          ctx.globalAlpha = 0.98;
          ctx.fillStyle = piece.color;
          roundedRect(x, y, unit, unit, 8);
          ctx.shadowColor = "rgba(0,0,0,0.4)";
          ctx.shadowBlur = 12;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.16;
          ctx.fillStyle = "#fff";
          roundedRect(x + 2, y + 2, unit - 4, unit - 4, 8);
          ctx.fill();
          ctx.restore();
        }
      }
      function drawReturnAnim() {
        if (!returnAnim) return;
        const r = returnAnim;
        const t = Math.min(1, (now() - r.start) / r.dur);
        const ease = t * (2 - t);
        const ix = r.from.x + (r.to.x - r.from.x) * ease;
        const iy = r.from.y + (r.to.y - r.from.y) * ease;
        const piece = tray[r.pieceIdx];
        const unit = 30,
          gap = 6;
        for (const [dx, dy] of piece.shape) {
          const x = ix + dx * (unit + gap);
          const y = iy + dy * (unit + gap);
          ctx.globalAlpha = 0.96;
          ctx.fillStyle = piece.color;
          roundedRect(x, y, unit, unit, 8);
          ctx.shadowColor = "rgba(0,0,0,0.4)";
          ctx.shadowBlur = 12;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
        if (t >= 1) returnAnim = null;
      }
      function drawFloatingTexts() {
        if (!floatingTexts.length) return;
        ctx.font = `700 ${16}px Poppins`;
        ctx.textAlign = "center";
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
          const f = floatingTexts[i];
          ctx.globalAlpha = f.alpha;
          ctx.fillStyle = "#ffffff";
          ctx.shadowColor = "rgba(0,0,0,0.5)";
          ctx.shadowBlur = 5;
          ctx.fillText(f.text, f.x, f.y);
          ctx.shadowBlur = 0;
          f.y += f.vy;
          f.vy *= 0.98;
          f.alpha -= 0.02;
          if (f.alpha <= 0) floatingTexts.splice(i, 1);
        }
        ctx.globalAlpha = 1;
      }
      function drawSparks() {
        for (let i = sparks.length - 1; i >= 0; i--) {
          const p = sparks[i];
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.alpha;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 6;
          ctx.fill();
          ctx.shadowBlur = 0;
          p.x += p.vx;
          p.y += p.vy;
          p.vy += p.gravity;
          p.alpha -= 0.02;
          if (p.alpha <= 0) sparks.splice(i, 1);
        }
        ctx.globalAlpha = 1;
      }
      function drawGameOverAnim() {
        if (!gameoverAnim) return;
        const { start, dur, x, y } = gameoverAnim;
        const t = Math.min(1, (now() - start) / dur);
        const radius = t * CANVAS_W * 0.8;
        const alpha = 1 - Math.pow(t, 2);
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.4})`);
        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${alpha * 0.2})`);
        gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
      }
      function drawStarParticles() {
        for (let i = starParticles.length - 1; i >= 0; i--) {
          const p = starParticles[i];
          const t = (now() - p.start) / p.dur;
          if (t > 1) {
            starParticles.splice(i, 1);
            continue;
          }
          const ease = t;
          ctx.globalAlpha = p.alpha * (1 - ease);
          const size = p.size * (1 - ease * 0.5);
          const x = p.x + p.vx * ease;
          const y = p.y + p.vy * ease;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.moveTo(x + size, y);
          for (let j = 0; j < 5; j++) {
            ctx.lineTo(
              x + Math.cos(((18 + j * 72) * Math.PI) / 180) * size,
              y - Math.sin(((18 + j * 72) * Math.PI) / 180) * size
            );
            ctx.lineTo(
              x + Math.cos(((54 + j * 72) * Math.PI) / 180) * size * 0.5,
              y - Math.sin(((54 + j * 72) * Math.PI) / 180) * size * 0.5
            );
          }
          ctx.closePath();
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 8;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;
      }

      /* ------------- RENDER (d·ª±a tr√™n dirty flag) ------------- */
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoardPanel();
        drawGrid();
        if (dragging && dragPos) {
          const ghost = ghostFromPointer(
            tray[dragging.pieceIdx],
            dragPos.x,
            dragPos.y - 10
          );
          if (ghost) drawGhost(ghost.cells, ghost.valid);
        }
        drawTray();
        drawSparks();
        drawStarParticles();
        drawFloatingTexts();
        drawDraggedPieceVisual();
        drawReturnAnim();
        drawGameOverAnim();
      }

      /* ------------- LOGIC TR√í CH∆†I C·ªêT L√ïI ------------- */
      function canPlace(piece, gx, gy) {
        for (const [dx, dy] of piece.shape) {
          const x = gx + dx,
            y = gy + dy;
          if (x < 0 || x >= GRID || y < 0 || y >= GRID) return false;
          if (board[y][x] !== 0) return false;
        }
        return true;
      }
      function placePiece(piece, gx, gy) {
        for (const [dx, dy] of piece.shape) {
          const x = gx + dx,
            y = gy + dy;
          board[y][x] = piece.color;
          popAnims.set(keyOf(x, y), { start: now(), dur: 220 });
        }
      }
      function fullLines() {
        const rows = [],
          cols = [];
        for (let y = 0; y < GRID; y++)
          if (board[y].every((v) => v !== 0)) rows.push(y);
        for (let x = 0; x < GRID; x++) {
          let ok = true;
          for (let y = 0; y < GRID; y++)
            if (board[y][x] === 0) {
              ok = false;
              break;
            }
          if (ok) cols.push(x);
        }
        return { rows, cols };
      }
      function clearLines(rows, cols) {
        const cellsToClear = new Set();
        for (const y of rows) {
          for (let x = 0; x < GRID; x++) {
            cellsToClear.add(keyOf(x, y));
            const cx = BOARD_PAD + x * (CELL + GAP) + CELL / 2;
            const cy = BOARD_PAD + y * (CELL + GAP) + CELL / 2;
            const color = board[y][x];
            for (let i = 0; i < 8; i++) {
              sparks.push({
                x: cx,
                y: cy,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                gravity: 0.2,
                size: Math.random() * 4 + 2,
                color: color,
                alpha: 1,
              });
            }
          }
        }
        for (const x of cols) {
          for (let y = 0; y < GRID; y++) {
            cellsToClear.add(keyOf(x, y));
            const cx = BOARD_PAD + x * (CELL + GAP) + CELL / 2;
            const cy = BOARD_PAD + y * (CELL + GAP) + CELL / 2;
            const color = board[y][x];
            for (let i = 0; i < 8; i++) {
              sparks.push({
                x: cx,
                y: cy,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                gravity: 0.2,
                size: Math.random() * 4 + 2,
                color: color,
                alpha: 1,
              });
            }
          }
        }
        setTimeout(() => {
          for (const key of cellsToClear) {
            const [x, y] = key.split(",").map(Number);
            board[y][x] = 0;
          }
          dirty = true;
        }, 100);
        playSound("clear");
      }
      function maybeRefillTray() {
        if (tray.every((p) => p.used)) {
          tray = [randomPiece(), randomPiece(), randomPiece()];
          layoutTray();
          dirty = true;
        }
      }
      function anyMovesLeft() {
        for (const p of tray) {
          if (p.used) continue;
          let tempShape = cloneShape(p.shape);
          for(let r=0; r<4; r++){
              for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                  if (canPlace({shape: tempShape}, x, y)) return true;
                }
              }
              if(p.rotatable) {
                  tempShape = rotateRight(tempShape);
              } else {
                  break;
              }
          }
        }
        return false;
      }

      function rotatePieceInTray(pieceIdx) {
        if (isPaused) return;
        if (tray[pieceIdx].rotatable) {
          const piece = tray[pieceIdx];
          const newShape = rotateRight(piece.shape);
          piece.shape = newShape;
          playSound("rotate");
          dirty = true;
        }
      }
      /* ---------- C√ÅC H√ÄM X·ª¨ L√ù OVERLAY V√Ä HI·ªÜU ·ª®NG ---------- */
      function showGameoverOverlay() {
        overlayScore.textContent = score;
        overlayBest.textContent = best;
        gameoverOverlay.classList.add("show");
        playSound("gameover");
        gameoverAnim = { start: now(), dur: 1000, x: CANVAS_W / 2, y: CANVAS_H / 2 };
      }
      function hideGameoverOverlay() {
        gameoverOverlay.classList.remove("show");
        gameoverAnim = null;
      }
      function showPauseOverlay() {
        isPaused = true;
        pauseOverlay.classList.add("show");
      }
      function hidePauseOverlay() {
        isPaused = false;
        pauseOverlay.classList.remove("show");
      }
      function switchView(viewId) {
        document.querySelectorAll(".views").forEach((view) => {
          view.classList.remove("active");
        });
        document.getElementById(viewId).classList.add("active");
      }

      /* ---------- HI·ªÜU ·ª®NG TR·∫¢ L·∫†I ---------- */
      function animateReturnToSlot(pieceIdx, from, dur = 460) {
        const slot = tray[pieceIdx].slotRect;
        const to = { x: from.x + (slot.x - from.x), y: from.y + (slot.y - from.y) };
        returnAnim = { pieceIdx, from, to, start: now(), dur };
      }

      /* ---------- PH√ÅO HOA V√Ä H·∫†T L·∫§P L√ÅNH ---------- */
      function spawnConfetti(cx, cy, n = 36) {
        for (let i = 0; i < n; i++) {
          sparks.push({
            x: cx,
            y: cy,
            vx: (Math.random() - 0.5) * 12,
            vy: -(3 + Math.random() * 10),
            gravity: 0.3,
            size: Math.random() * 4 + 2,
            color: rand(COLORS),
            alpha: 1,
          });
        }
        playSound("victory");
      }
      function spawnStarParticles(x, y, count = 20, color = "#FFD700") {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 5 + 3;
          starParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 4 + 2,
            color: color,
            alpha: 1,
            start: now(),
            dur: 1000,
          });
        }
      }

      /* ---------- X·ª¨ L√ù ƒê·∫¶U V√ÄO C·ª¶A NG∆Ø·ªúI D√ôNG ------------- */
      function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches && e.touches.length)
          return {
            x: e.touches[0].clientX - rect.left,
            y: e.touches[0].clientY - rect.top,
          };
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
      function hitTray(mx, my) {
        for (let i = 0; i < 3; i++) {
          const s = tray[i].slotRect;
          if (!s) continue;
          if (
            mx >= s.x &&
            mx <= s.x + s.w &&
            my >= s.y &&
            my <= s.y + s.h &&
            !tray[i].used
          )
            return i;
        }
        return -1;
      }
      function getPieceOffset(piece, mx, my, slot) {
          const { w, h } = boundsOf(piece.shape);
          const unit = 30,
            gap = 6;
          const pw = w * unit + (w - 1) * gap,
            ph = h * unit + (h - 1) * gap;
          const px = slot.x + Math.round((slot.w - pw) / 2),
            py = slot.y + Math.round((slot.h - ph) / 2);

          return { offsetX: mx - px, offsetY: my - py };
      }

      function handlePointerDown(e) {
        if (isPaused) return;
        const p = getPointerPos(e);
        const idx = hitTray(p.x, p.y);
        if (idx >= 0) {
          const piece = tray[idx];
          const offsets = getPieceOffset(piece, p.x, p.y, tray[idx].slotRect);

          dragging = {
            pieceIdx: idx,
            offsetX: offsets.offsetX,
            offsetY: offsets.offsetY,
            pointerId: e.pointerId,
          };

          dragPos = getPointerPos(e);
          try {
            canvas.setPointerCapture(e.pointerId);
          } catch (e) {}
          playSound("place");
          dirty = true;
        }
      }

      let lastMove = 0;
      function handlePointerMove(e) {
        if (!dragging || isPaused) return;
        const t = performance.now();
        if (t - lastMove < 8) return;
        lastMove = t;
        dragPos = getPointerPos(e);
        dirty = true;
      }

      function handlePointerUp(e) {
        if (!dragging || isPaused) return;
        const p = getPointerPos(e);
        const piece = tray[dragging.pieceIdx];
        const ghost = ghostFromPointer(
          piece,
          p.x,
          p.y - 10
        );
        if (ghost && ghost.valid) {
          placePiece(piece, ghost.gx, ghost.gy);
          piece.used = true;
          
          score += 15; // ƒê√£ thay ƒë·ªïi: ƒê·∫∑t 1 kh·ªëi + 15 ƒëi·ªÉm
          scoreEl.textContent = score;

          const { rows, cols } = fullLines();
          if (rows.length || cols.length) {
            const totalLines = rows.length + cols.length;
            const lineClearBonus = totalLines * 30; // ƒê√£ thay ƒë·ªïi: Ph√° h√†ng +30 ƒëi·ªÉm m·ªói h√†ng
            score += lineClearBonus;
            scoreEl.textContent = score;

            clearLines(rows, cols);

            floatingTexts.push({
              x: CANVAS_W / 2,
              y: BOARD_PAD + 100,
              text: `+${lineClearBonus}`,
              vy: -1.6,
              alpha: 1,
            });

          }
          afterPlace();
        } else {
          const from = { x: p.x - dragging.offsetX, y: p.y - dragging.offsetY };
          animateReturnToSlot(dragging.pieceIdx, from, 420);
          floatingTexts.push({
            x: p.x,
            y: p.y,
            text: "Kh√¥ng th·ªÉ ƒë·∫∑t",
            vy: -1.2,
            alpha: 1,
          });
        }
        try {
          canvas.releasePointerCapture(e.pointerId);
        } catch (e) {}
        dragging = null;
        dragPos = null;
        dirty = true;
      }

      function handlePointerCancel(e) {
        if (!dragging) return;
        const p = getPointerPos(e);
        const from = { x: p.x - dragging.offsetX, y: p.y - dragging.offsetY };
        animateReturnToSlot(dragging.pieceIdx, from, 420);
        try {
          canvas.releasePointerCapture(e.pointerId);
        } catch (e) {}
        dragging = null;
        dragPos = null;
        dirty = true;
      }

      function handleLostPointerCapture(e) {
        if (!dragging) return;
        const p = dragPos;
        const from = { x: p.x - dragging.offsetX, y: p.y - dragging.offsetY };
        animateReturnToSlot(dragging.pieceIdx, from, 420);
        dragging = null;
        dragPos = null;
        dirty = true;
      }

      /* ---------- SAU KHI ƒê·∫∂T KH·ªêI ---------- */
      function afterPlace() {
        let newBest = false;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
          localStorage.setItem("bb_best_polished", String(best));
          newBest = true;
        }
        maybeRefillTray();
        if (newBest) {
          spawnConfetti(CANVAS_W / 2, BOARD_PAD + BOARD_SIZE / 2, 48);
          spawnStarParticles(CANVAS_W / 2, CANVAS_H / 2, 30);
          floatingTexts.push({
            x: CANVAS_W / 2,
            y: BOARD_PAD + 120,
            text: `üéâ K·ª∑ l·ª•c m·ªõi: ${best}`,
            vy: -1.6,
            alpha: 1,
          });
        }
        if (!anyMovesLeft()) {
          setTimeout(() => {
            showGameoverOverlay();
          }, 120);
        }
        dirty = true;
      }

      /* ---------- V√íNG L·∫∂P Y√äU C·∫¶U (tick) ---------- */
      function tick() {
        if (isPaused) {
            rafId = null;
            return;
        }
        if (
          sparks.length ||
          floatingTexts.length ||
          returnAnim ||
          dragging ||
          gameoverAnim ||
          starParticles.length ||
          popAnims.size > 0
        ) {
          dirty = true;
        }
        if (dirty) {
          render();
          dirty = false;
        }
        rafId = requestAnimationFrame(tick);
      }

      /* ---------- ƒêI·ªÄU KHI·ªÇN N√öT V√Ä GIAO DI·ªÜN ---------- */
      classicBtn.addEventListener("click", () => {
        initGame('classic');
        switchView("game-view");
      });
      dynamicBtn.addEventListener("click", () => {
        initGame('dynamic');
        switchView("game-view");
      });
      overlayReplay.addEventListener("click", () => {
        hideGameoverOverlay();
        initGame(gameMode);
      });
      replayInPauseBtn.addEventListener("click", () => {
        hidePauseOverlay();
        initGame(gameMode);
      });
      muteBtn.addEventListener("click", () => {
        audioEnabled = !audioEnabled;
        muteBtn.textContent = audioEnabled ? "üîä" : "üîà";
        muteBtn.setAttribute("aria-pressed", audioEnabled ? "true" : "false");
      });
      bgmBtn.addEventListener("click", () => {
        toggleBGM();
      });
      pauseBtn.addEventListener("click", () => {
        togglePause();
      });
      closePauseBtn.addEventListener("click", () => {
        togglePause();
      });
      backToHomeBtn.addEventListener("click", () => {
        hidePauseOverlay();
        switchView("home-view");
      });
      document.addEventListener('click', (e) => {
        if(e.target.classList.contains('rotate-btn')) {
          const pieceIndex = e.target.closest('.tray-piece-wrap').dataset.pieceIndex;
          rotatePieceInTray(parseInt(pieceIndex, 10));
        }
      });

      /* ---------- kh·ªüi ƒë·ªông tr√≤ ch∆°i v√† c√°c s·ª± ki·ªán chung ---------- */
      switchView("home-view");
      resizeGame();
      window.addEventListener("resize", resizeGame);
      canvas.addEventListener("pointerdown", handlePointerDown);
      canvas.addEventListener("pointermove", handlePointerMove);
      canvas.addEventListener("pointerup", handlePointerUp);
      canvas.addEventListener("pointercancel", handlePointerCancel);
      canvas.addEventListener("lostpointercapture", handleLostPointerCapture);
      canvas.addEventListener("touchstart", (e) => e.preventDefault(), {
        passive: false,
      });
      canvas.addEventListener("touchmove", (e) => e.preventDefault(), {
        passive: false,
      });
      gameoverOverlay.addEventListener("click", (ev) => {
        if (ev.target === gameoverOverlay) {
          hideGameoverOverlay();
        }
      });
      pauseOverlay.addEventListener("click", (ev) => {
        if (ev.target === pauseOverlay) {
          togglePause();
        }
      });
    </script>
  </body>
</html>
